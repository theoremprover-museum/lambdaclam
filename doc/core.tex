\chapter{The Structure of the \lclam\ Proof Planning
Mechanism\index{proof planning}\index{planner}}
\label{core}

\section{Introduction}
The basic planning mechanism at the heart of \lclam\ is not about
induction\index{induction} or rippling\index{rippling} or any
specialised methods or heuristics for automated proof.  It is intended
to provide some machinery upon which such methods\index{method} and
heuristics can be built.

This basic machinery consists of the notions of terms\index{term},
types\index{type}, methods\index{method}, critics\index{critics} and
plans\index{proof plan}.  At present \lclam\ doesn't provide much by
way of support for tactics\index{tactic} --- although this may change
in the future, when we hopefully will attach a theorem prover to
\lclam.

This chapter considers each of the aspects of the planning mechanism
in turn in a general way.  A person developing their own strategy
\index{proof strategy} (method waterfall\index{method!waterfall}),
logic\index{object-level logic}, etc. in \lclam\ should not have to
alter any of the files contained in the core planning part of \lclam\ 
(i.e. any of the subdirectories of {\tt src} apart from {\tt
  theories}).  However, it is useful to have a general understanding
of what they do.


\section{The Plan Data Structure\index{Plan Data Structure}}
Our plans looks something like figure~\ref{fig:andplan}.
\begin{figure}[htb]
\begin{center}\leavevmode
\epsfbox{fig:currentplan.eps}
\end{center}
\caption{A Proof Plan}
\label{fig:andplan}
\end{figure}
A proof plan\index{proof plan} is a labelled tree\index{labelled tree}
--- the labels contain a lot of information {\em possibly redundant?}.
Only the goal\index{goal} is shown in the figure, but they are also
labelled with the name of the method\index{method} applied at the
node, the methodical continuation\index{methodical continuation} etc.
All the nodes in this tree are {\em and} nodes\index{and node}, that
is for the plan to be successfully completed, each branch below a node
must also be successfully completed.  As well as the standard {\em
  and} nodes the plan can contain quantified nodes (indicated by the
{\tt EXISTS X} in the figure).  These are usually generated by the
elimination of quantifiers from goals and replacing with arbitrary
constants (for universally quantified goals) or
meta-variables\index{meta-variable} (for existentially quantified
goals).  This quantification happens at the meta-level.  In the goals,
{\tt X} appears as a meta-variable (for an {\em exists}
node\index{exists node}) or an arbitrary constant (for a {\em forall}
node\index{forall node}) as it does in any other part of the label
(e.g. the Method or the Tactic) which use it.  It is also treated
uniformly in all the children of the node since they fall within the
scope of the meta-level quantifier.  The basic plan
constructors\index{plan constructor} are therefore {\em and} nodes,
{\em forall} nodes and {\em exists} nodes.

You'll also notice in the figure a two step process by which a goal
produces two subgoals as its child and then these two subgoals are
split into two child nodes as a separate step.  This no doubt seems a
bit excessive.  This arises because of the large amount of information
on the plan node labels.  When a method is applied to a goal and it
produces two subgoals the method writer is only interested in
specifying what those subgoals are {\em not} in working out all the
details of how those goals should be labelled.  He therefore uses the
{\tt **}\index{**} constructor to join the two goals together.  For
instance the {\tt and\_i}\index{and\_i} method in the constructive
logic theory\index{constructive logic theory} is as follows:
\begin{verbatim}
atomic constructive_logic and_i 
           (seqGoal (H >>> (app and (tuple [A, B])))) 
           true 
           true
           ((seqGoal (H >>> A)) ** (seqGoal (H >>> B))) 
           notacticyet.
\end{verbatim}
This represent the sequent calculus rule:
\begin{equation}
\frac{\Gamma \vdash A \hspace{0.5cm} \Gamma \vdash B}{\Gamma \vdash A
  \wedge B}
\end{equation}
i.e. to prove $A \wedge B$ you need to prove both $A$ and $B$.  {\tt
  **} is used to indicate this conjunction of goals.  The next node in
the proof plan of this is therefore labelled with the goal expression
$\Gamma \vdash A {\tt **} \Gamma \vdash B$ which is then split into
two with proper labelling for the other parts of the plan added at the
next step.  This is more than a little inelegant and other
presentations have been tried - e.g. getting method application and
splitting to happen at once.  It is unclear which version is to be
preferred.

\section{The Partial Data Structure Planner\index{Partial Data
    Structure Planner}\index{PDS Planner}} 

\subsection{Basic Planning algorithm\index{PDS Planner!algorithm}}
The basic building blocks of the planning algorithm are two predicates 
one for planning one step of a plan - i.e. taking a goal, applying a
method to it and producing a subgoal, and one for recursively
repeating this process to produce a plan.  After each single step a
new agenda\index{agenda} of open plan nodes is created and this
determines which goal is attempted next by the planner.  A record is
also kept of the next {\em action}\index{action} to be attempted.  The 
default action is to add new nodes onto an agenda as a result of
method application, but in certain situations - where designated
methods have failed the action is an instruction to attempt to apply a 
critic\index{critic} to the node.

\begin{verbatim}
PLAN Agenda Action
      If the Agenda is empty succeed.
PLAN Agenda Action
      PLAN_ONE_STEP by applying a method or a critic to the
first node on the Agenda (as specified by the Action).  Get a
NewAction as a result.
      CREATE_AGENDA a NewAgenda using the results of PLAN_ONE_STEP
      PLAN NewAgenda NewAction.
\end{verbatim}

{\tt PLAN\_ONE\_STEP} plans one step of a plan by expanding the
methodical\index{methodical} 
definition to get a first method and applying it at a node to generate 
a new node.  Similarly if the instruction is to apply a
critic\index{critic} {\tt PLAN\_ONE\_STEP} does this and modifies the
existing plan accordingly.

{\tt CREATE\_AGENDA} determines whether planning will proceed
depth-first\index{depth first}, breadth first\index{breadth first} or
by some other more sophisticated process.  By default planning is
depth-first but the predicates described take an {\em agenda
  predicate}\index{agenda predicate} as an argument and it is this
predicate that is used to create the new agenda.  This allows users to 
customise the search process.

It is during {\tt CREATE\_AGENDA} that any user intervention in terms
of selecting the next node for planning or forcing
backtracking can occur.  

\subsubsection{Applying Methods}
\label{planonestep}

The {\tt
  PLAN\_ONE\_STEP} algorithm essentially applies a method to an open node
in the plan and outputs a new plan.  The step plan selects a node, gets
a first method 
and the method continuation and then applies the method to the node to 
generate child nodes.

Recall that methods can be either {\em atomic} or {\em compound}.  An
atomic method\index{method!atomic} has the traditional five slots
(input goal\index{input goal},
preconditions\index{preconditions},
postconditions\index{postconditions}, output goals\index{output goal}, tactic\index{tactic}).  A compound
method\index{method!compound} is an expression built up of chaining
together methods with 
{\em methodicals}\index{methodical}.  So the step case\index{step case} of an induction is expressed as 
\begin{verbatim}
compound induction step_case  
        (then_meth
           (repeat_meth (wave_method outward R))
              (orelse_meth fertilisation_strong
                (then_meth      
                   (try_meth (repeat_meth 
                      (patch_meth (wave_method inout R1) wave_critic_strat)))
                   (try_meth fertilise)
                )
              )
        )
        _
        true.
\end{verbatim}
NB.  This is a simplified version of the {\tt step\_case} method which
is in actuality more than a little baroque in order to cope with a
number of special cases.  This method instructs the planner to ripple
outwards\index{ripple!outward} then attempt
fertilisation\index{fertilise}.  If that fails it ripples
inwards\index{ripple!inward} and tries fertilising again.  The {\tt
  patch\_meth}\index{patch\_meth} methodical\index{methodical} around
the ripple in method says that if this method fails the critic {\tt
  wave\_critic\_strat}\index{wave\_critic\_strat} should be applied to
the node.

Julian and Alan S. have shown in BBNote 1349 that all these methodical 
expression can be transformed to give the first method to be
applied and then a {\em method continuation}\index{method!continuation}, a new methodical
expression indicating how to deal with the rest of the expression.
For example the first method to be applied in {\tt then\_meth M1 M2}
is the first method of {\tt M1} (found by recursing through the
expression) and the continuation is {\tt then\_meth M1Cont M2} where
{\tt M1Cont} is the continuation of {\tt M1} found by recursing
through the expression.  This does not concern itself with whether a
method within this expression is compound or atomic, e.g. {\tt
  fertilise}\index{fertilise} above is compound but will be returned
as the first method  
of the expression once {\tt post\_ripple}\index{post\_ripple} has been
applied.    The 
sequence of methods and methodical expressions  
leading up to the ``top method'' applied to a planning problem is
referred to as the {\em method waterfall}\index{method!waterfall}. 

{\tt APPLY\_METHOD}, used after the methodical expression has been
transformed into a first method and a continuation, distinguishes
between the atomic and compound methods and treats them differently in 
method application.

\begin{verbatim}
PLAN_ONE_STEP Agenda Action
     If Action says to apply a method
     Pick the first node on the Agenda and find the Goal and
Methodical Expression
     TRANSFORM The Methodical expression into a First Method and a
Method Continuation as specified in BBNOTE 1349
     APPLY the First Method to the Goal to get some Subgoals,
     ADD a new node to the plan of the the subgoal annotated with the
Method Continuation as the Methodical Expression.

APPLY Method to Goal return the Subgoal
     Method is atomic and its slots are: 
              Goal Preconditions Postconditions Subgoal
     Preconditions succeed
     Postconditions succeed
APPLY_METHOD Method to Goal return the Subgoal
     Method is compound with Preconditions and a MethodExpansion
     Preconditions succeed
     The Subgoal is the same as the Goal but with the Methodical
Expression being (then_meth MethodExpansion MethodContinuation)
\end{verbatim}

{\tt APPLY} has special cases for splitting up compound goals and
moving goal quantification to plan quantification.

\subsubsection{Applying Critics\index{critic!application}}
I also mentioned that {\tt PLAN\_ONE\_STEP} deals with
critics\index{critic}.  

Like methods\index{method}, critics are expressed using a
waterfall\index{waterfall!critic} of compound and atomic
critics\index{critic!compound}\index{critic!atomic}.  So the {\tt
  wave\_critic\_strat}\index{wave\_critic\_strat} mentioned above is a 
compound critic:
\begin{verbatim}
compound_critic wave wave_critic_strat
        (then_crit (pop_critic FailAd)
        (then_crit (subplan_crit FailAd (then_crit (wave_failure Failure Rule)
                                         open_node))
                   (wave_patch Failure FailAd Rule))).
\end{verbatim}
This instructs the planner to find the address of the node at which
the plan failed {\tt pop\_critic}\index{pop\_critic}, then at that
address ({\tt subplan\_crit}\index{subplan\_crit}) analyse the cause
of failure ({\tt wave\_failure}\index{wave\_failure}) and patch the
plan accordingly ({\tt wave\_patch}\index{wave\_patch}).

The critic waterfall\index{waterfall!critic} is worked through in a
very similar way to the method waterfall\index{waterfall!method}.
Consider the situation where a rewrite\index{rewrite} has failed
because the condition, $C$, on the rewrite $C \rightarrow L \rewrites
R$ can not be shown to be true.  One patch is to create two new
subgoals, one in which $C$ is true and one in which $\neg C$ is true
in the hypotheses lists and attempt to prove both.  The instantiation
of {\tt wave\_patch}\index{wave\_patch} in this case is
\begin{verbatim}
compound_critic wave (wave_patch (failed_cond Rule) Ad Rule)
        (subplan_crit Ad 
           (continue_crit (m\ (then_meth (wave_case_split Rule) 
                (map_meth m))))).
\end{verbatim}
This tells the planner to continue planning using a new method {\tt
  wave\_case\_split}\index{wave\_case\_split} that does not appear in
the usual waterfall.  This method performs the casesplit dictated by
the rule.  It then maps the existing methodical
continuation\index{methodical continuation} at that plan node, {\tt
  m}, over all the subgoals produced by the new method.

Atomic critics\index{critic!atomic} have slots for the address at
which they are applied, the current agenda, their preconditions and
effects, any changes they make to the plan and the new agenda.  So,
for instance the built-in critic {\tt
  roll\_back\_to\_crit}\index{roll\_back\_to\_crit} rolls back the
plan to the last occurrence of a specified method.  To do this its
preconditions examine the current plan for the nearest address to the
input address at which the method occurred.  It then calculates all the 
nodes that appear after that method and returns a list of these marked 
for deletion.  It also removes them from the agenda and puts the node
where the method was applied back on the agenda marking it as an open
node.

Usually atomic critics examine preconditions\index{preconditions} of
the failed method.  For instance the {\tt
  wave\_failure}\index{wave\_failure} critic shown below:
\begin{verbatim}
atomic_critic wave (wave_failure Failure Rule)
        Address
        Agenda
        (get_preconditions Address Pre, 
         failed_pre Pre Failed,
         wave_failed Pre Failed Failure)
        true
        nil
        Agenda.
\end{verbatim}
In this case it makes no changes to the plan and leaves the
agenda\index{agenda} as it was.  However it finds the preconditions,
{\tt Pre} at the input address and analyses them to get a diagnosis of
the sort of failure - e.g. {\tt failed\_cond}\index{failed\_cond}
discussed above.

In order for it to be possible to analyse
preconditions\index{preconditions} in this way the planner annotates
plan nodes with precondition information (along with method and method
continuation\index{method}\index{method!continuation} etc. etc.).
Usually the preconditions are simply marked as successful, but if a
method has failed to apply and it occurs within a {\tt
  patch\_meth}\index{patch\_meth} expression then its preconditions
are evaluated one at a time.  Those that succeed are marked {\tt
  success} and those that fail are marked {\tt failed}.  These can
then be analysed.

