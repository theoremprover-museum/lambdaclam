%=========================
%%   Systemnamen
%%=========================

\newcommand{\Nat}{{\mathchoice{\displaystyle\rm I\hskip-0.21em N}%
{\textstyle\rm I\hskip-0.21em N}%
{\scriptstyle\rm I\hskip-0.14em N}%
{\scriptscriptstyle\rm I\hskip-0.14em N}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\eps{\epsilon}
\def\name#1{#1}
\def\xspace{}
\def\activemath{{\it ActiveMath}}
\def\analytica{{\it Analytica}}
\def\automath{AUTOMATH}
\def\bliksem{{\it Bliksem}}
\def\chip{\mbox{CHIP}\xspace}
\def\chorus{Chorus}
\def\clamlite{{CLAM-Lite}}
\def\clos{{{\small CLOS}}}
\def\commonlisp{{{\footnotesize COMMON LISP}}}
\def\corba{{\sc Corba}}
\def\cosie{${\cal C}o{\cal SIE}$}

\def\davinci{\mbox{\sc daVinci}\xspace}
\def\declame{{{\small DECLAME}}}
\def\discount{{DISCOUNT}}
\def\doris{DORIS}
\def\eclipse{ECL$^i$PS$^e$}
\def\eqp{EQP}
\def\eprover{{\sf E}}

\def\fipa{{\sf FIPA}}
\def\fscos{${\cal FSC}o{\cal S}$}
\def\HOL{{$\cal HOL$}}
\def\hr{{\sf HR}}
\def\http{{\sf http}}

\def\ilf{{ILF}}
\def\ilog{ILOG}
\def\imply{IMPLY}
\def\imps{\mbox{\sc IMPS}\xspace}
\def\isabelle{\mbox{\it Isabelle}\xspace}

\def\keim{{\small\bf KEIM}}
\def\KEIM{{\small\bf KEIM}}
\def\kimba{{\sf Kimba}}
%\def\kqml{{\sc Kqml}}
\def\kqml{KQML}
\def\larks{LARKS}
\def\mathml{{\sc MathML}}
\def\oants{{\sf OANTS}}
\def\omrs{{\sc OMRS}}
\def\openmath{{\sc OpenMath}}
\def\omdoc{{OMDoc}} %\protect\omdocaux}
\def\omdocaux{\sc O\kern-1.6ex\raisebox{.4ex}{{\tiny M}}Doc}
\def\prosper{{\sc Prosper}}
\def\pvs{PVS}
\def\setheo{{SETHEO}}
\def\teamwork{{\sc Teamwork}}
\def\techs{{TECHS}}
\def\waldmeister{Waldmeister}
\def\xml{XML}
\def\xsl{{\sc Xsl}}

\def\lams{{\sf LaMS}}
\def\leo{\mbox{${\cal LEO}$}\xspace}
\def\lineq{{\sc LinEQ}}
\def\lisp{{\footnotesize LISP}}
%\def\loui{\mbox{{\sc L}$\Omega${\sc UI}}\xspace}
\def\LOUI{\mbox{\sc L}{\sc ovely} {$\Omega${\sc mega}} {\sc U}{\sc ser} {\sc I}{\sc nterface}}

\def\gap{GAP}
\def\cocoa{CoCoA}
\def\lba{LBA}
\def\lclam{\mbox{$\lambda$\--Clam}}
\def\mace{MACE}
\def\magma{{\sc MagMa}}
\def\maple{{\sc Maple}}
\def\mass{{\sc Mass}}
\def\mathematica{{\it Mathematica}}
\def\mathpert{{\it Mathpert}}
\def\mathweb{Math\-Web}
\def\mathwebsb{Math\-Web-SB}
\def\mathagent{\mbox{\sc MathAgent}\xspace}
\def\mbase{{\sc MBase}}
\def\mkrp{{MKRP}}
\def\mosh{\sc MoSh}
\def\mozart{\sc Mozart}
\def\multi{MULTI}
\def\mycas{\mbox{$\mu$\hspace{.2em}${\cal CAS}$}}
\def\MYCAS{\mbox{$\mu${\sc CAS}}}
\def\myCAS{\mbox{$\mu${\sc CAS}}}

\def\ND{{\small\bf ND}}
\def\nuprl{{Nuprl}}
\def\octopus{\mbox{$\Omega${\sc cTOpus}}\xspace}
\def\OMEGA{$\Omega${\sc mega}}
\def\omws{OMWS}
\def\otter{{\sc Otter}}
\def\oyster{{\mbox{\rm O\kern-.12em\raise.39ex\hbox{\sc y}\kern-.07emS\kern-.39em\raise.39ex\hbox{\sc t}\kern-.15em\hbox{\sc e}R}}}
\def\oz{{\sc Oz}}

\def\pds{PDS}
\def\POST{{\mbox{$\cal POST$}}}
\def\post{{\POST}}
\def\Post{{\POST}}
\def\prolog{PROLOG}
\def\lprolog{$\lambda$-PROLOG}
\def\protein{\mbox{\sc ProTeIn}\xspace}
\def\proverb{{\it PROVERB\/}}
\def\rdl{{\bf RDL}}
\def\sapper{{\sc sapper}}
\def\scetchpad{\mbox{SCETCHPAD}}
\def\solex{{\bf\sf SoleX}}
\def\spass{\mbox{\sc Spass}\xspace}
\def\strips{{\small STRIPS}}
\def\teyjus{Teyjus}
\def\tramp{{\sc TRAMP}}
\def\tps{TPS}
\def\tptp{{\sc TPTP}}
\def\tptptox{tptp2X}
\def\vampire{Vampire}
\def\weierstrass{{\it Weierstrass}}
\def\xmlrpc{XML-RPC}

%%\def\CLOS{{{\footnotesize COMMON LISP Object System}}}
\def\Omegapackage{{{\small\bf OMEGA}}}
%\def\clam{{\mbox{\rm CL\kern-.36em\raise.39ex\hbox{\sc a}\kern-.15emM}}}


\def\nd{{\bf ND}-Kalk"ul}
\def\lamcalc{\mbox{$\lambda$-Kalk"ul}}
\def\todo#1{{\sc #1}}
                                %\def\proverb{\mbox{\sc Proverb}\xspace}
                                %\def\clam{\mbox{\sc Clam}\xspace}
\def\hol{\mbox{\sc HOL}\xspace}
\def\nqthm{${\sc Nqthm}$}
                                %\def\tps{\mbox{\sc Tps}\xspace}
\def\clpr{\mbox{CLP(${\cal R}$)}\xspace}
\def\lmlb{\mbox{\sc LMLB}\xspace}
\def\LMLB{\mbox{\loui} {\sc M{\sc arkup}} {\sc L}{\sc anguage} {\sc B}{\sc rowser}}
\def\lml{\mbox{\sc LML}\xspace}
\def\LML{\mbox{\loui} {\sc M}{\sc arkup} {\sc L}{\sc anguage}}

\def\calculemus{\mbox{{\sc Calculemus}}}
\def\limplus{{\sc Lim-Plus}}
\def\limtimes{{\sc Lim-Times}}


\chapter{{\lclam} in the MathWeb Software Bus}\label{mathweb}

\author{J{\"u}rgen Zimmer}\footnote{The author was supported by the
  CALCULEMUS European Union IHP grant HPRN-CT-2000-00102.} (e-mail:
{\tt jzimmer@mathweb.org})\\
{\it This chapter summarises the work done by J{\"u}rgen Zimmer
  visiting the DREAM group as a CALCULEMUS Young Visiting Researcher
  (Oct. 2001 - Mar. 2002).}


\section{Introduction}
\label{sec:mw-intro}
The MathWeb Software Bus~\cite{FraKoh:mabdl99} is a platform for
distributed automated reasoning that supports the connection of a wide
range of mathematical services by a common software
bus.\footnote{Further information about the {\mathwebsb} is available
  at \url{http://www.mathweb.org/mathweb/}.}  The {\mathwebsb}
provides the functionality to turn existing reasoning systems into
mathematical services that are homogeneously integrated into a
networked proof development environment.  Client applications can
access 23 reasoning systems, for instance, the CASs {\maple},
{\magma}, and {\cocoa}, the constraint solver {\cosie}, mediators,
model generators, such as Mace and Satchmo, and the automated theory
formation system HR.  Moreover, the {\mathwebsb} integrates nine first
order ATPs, such as Otter, Spass and Bliksem, and E.
\begin{figure}[t]
 \begin{center}
   \epsfig{figure=mathweb-arch.eps,width=9cm}
   \caption{The MathWeb Software Bus}
   \label{fig:mathweb-arch}
 \end{center}
\end{figure}

The architecture of the MathWeb system is depicted in Fig.
\ref{fig:mathweb-arch}. Local {\em brokers} provide routing and
authentication information to the mathematical services. {\mathwebsb}
wrappers encapsulate the actual reasoning systems and offer the
mathematical services to their local broker.  Client applications such
as the {\OMEGA} system, HR, or {\lclam}, connect to a MathWeb broker
and request services.  In case the requested service is found, the
client application receives a reference to a newly created {\it
  service object}. The client can then send messages directly to this
service object.

\section{Integration of {\lclam}}
\label{sec:mw-integration}
We integrated {\lclam} into the {\mathwebsb} using the methodology
that has been successfully used for the integration of other systems
like the {\OMEGA} proof planner or the higher order theorem prover
{\tps}: A {\mathwebsb} {\it wrapper} implements the interface to the
services offered by {\lclam} and has full control over {\lclam} by
simulating user input using socket communication\footnote{Note: In the
  current implementation of Teyjus, socket communication only works on
  Solaris/SunOS machines.}. {\lclam} itself can use the wrapper to
access other services as external reasoning systems.

The implementation of {\lclam}, Teyjus {\lprolog}, does not allow
programming with multiple threads. Therefore, we had to define a new
interaction mode for {\lclam} in which the system reads commands from
the {\mathwebsb} socket:
\begin{description}
\item[{\tt sock\_read\_write}:] The top-level loop of a {\lclam}
  process in {\tt sock\_read\_write} mode exclusively reads commands
  from the {\tt lclam\_server\_socket}. The user cannot interact with
  the system via the usual toplevel loop.
%\item[{\tt sock\_interactive}:] I {\lclam} is running in {\tt
%    sock\_interactive} mode, the server socket is inactive. The {\tt
%    lclam\_client\_socket} can still be used to access external
%  reasoning systems in the {\mathwebsb}.
\end{description}

\subsection{Starting {\lclam} in the {\mathwebsb}}
To use {\lclam} within the {\mathwebsb} the system has to be
started by the {\lclam} {\mathweb} wrapper which establishes a socket
connection to the Teyjus process. This means, a {\mathwebsb}
installation is required.  At the moment, installing and configuring
the {\mathwebsb} is still a bit tricky. A detailed description of how
to install and configure the {\mathwebsb} can be found on the system's
homepage \url{http://www.mathweb.org/mathweb}. In the following we
only sketch the necessary steps to get an example session running on
DREAM machines:\\

\noindent Add the {\mozart} directory of the user {\tt jzimmer} to your path:
%\begin{itemize}
%\item {\tt cd \url{~}}
%\item {\tt ln -s /hame/jzimmer/.oz}
%\end{itemize}
%Expand your path to the Mozart directory:
\begin{itemize}
\item {\tt export  PATH=\$\{PATH\}:/hame/jzimmer/.oz/bin}
\end{itemize}
You can put this line in your \url{~/.bashrc} or your \url{~/.benv} file for the sake of convenience.

\noindent Copy {\mathwebsb}'s configuration files for the DREAM environment:
\begin{itemize}
\item {\tt cd \url{~}}
\item {\tt mkdir .mathweb}
\item {\tt cp -bi /hame/jzimmer/.mathweb/*config* .mathweb/}
\end{itemize}

The {\mathwebsb} expects that the environment variable
\url{LCLAM_HOME} is set to some installation of {\lclam} (Version 3.2.
or higher). If you don't have {\lclam} installed, please set the
variable to the installation of some other user, for instance, {\tt
  export LCLAM\_HOME=/hame/jzimmer/lclam}.  The same holds for the
variables {\tt TEYJUS\_HOME} which should point to the implementation
language {\teyjus}, and {\tt TJPATH} which defines the load-path of
{\teyjus} (cf.  section \ref{install}).
% instance:
%\begin{itemize}
%\item {\tt export TEYJUS\_HOME=/net/methven/disk/reason2/src/teyjus-test/juergen/teyjus-1.0-b30p2}
%\end{itemize}


\noindent Start the {\mathwebsb} and the {\lclam} system\footnote{Note that to be able to start
  {\tt lclam-mathweb} properly you should be a member of the user
  group {\tt dreamer}. Ask \url{gordon@dai.ed.ac.uk} for details.}  :
% {\mosh}\footnote{Further
%  information about the Mozart Shell (MoSh) can be found at
%  \url{http://www.mathweb.org/mathweb/mosh/}.} on methven or the host {\tt hostname}:
\begin{itemize}
\item {\tt lclam-mathweb}
\end{itemize}
An emacs window should appear with a {\lclam} process running in {\tt
  command\_pretty} mode. The system should behave like af ``normal''
{\lclam} except that the socket connection to the {\mathwebsb} wrapper
is established before the user is allowed to type in commands.  You
can try to plan a problem which uses the simplification of the
Computer Algebra System {\maple} during the planning process by typing
in the following commands:
\begin{alltt}
   add_theory_defs_to_sym_eval_list analytica.
   set_wave_rule_to_sym_eval.
   add_to_induction_scheme_list twostep2.
   pds_plan (induction_top normal_ind) fib_goal.
\end{alltt}
You should leave your {\lclam} system by typing {\tt halt.} in the
{\lclam} prompt and then {\tt C-x C-c} in the emacs window.


%Test {\lclam} with:
%\begin{itemize}
%\item {\tt testclam}
%\end{itemize}
%An emacs window should appear with a {\lclam} process running in {\tt
%  sock\_read\_write} mode.  After {\lclam} has finshed its search for
%a proof plan or after the time limit given by the test client is
%exceeded, the service is left again and the window should disappear.
%If the test worked fine, {\lclam} should be able to use all {\mathweb}
%services.

%To start an interactive {\lclam} session with an emacs interface, go
%to your {\mosh} and type
%\begin{itemize}
%\item {\tt lclam-mw}
%\end{itemize}
%The system should behave like af ``normal'' {\lclam} except that the
%socket connection to the {\mathwebsb} wrapper is established before
%the user is allowed to type in commands.


\section{{\lclam} using {\mathweb} Services}
\label{sec:mw-using-services}
For the use of external reasoning systems, we extended {\lclam} by the
modules \url{src/io/sockets.mod} and \url{src/plan/mathweb.mod} which
abstract from socket communication details and offers a convenient
interface to the {\mathwebsb} wrapper. The main predicates of the {\tt
  mathweb} module are the following:
\begin{description}
\item[{\tt mathweb\_get\_service}:]\ \\
  \hspace*{-1cm} {\small \tt string $\rightarrow$ string $\rightarrow$ o.}\\
  takes the service name as first argument (e.g.  "MAPLE", "OTTER")
  and returns a string uniquely identifying the service object in the
  second argument, if the service is available. If the service is not
  available, the predicate returns the string {\tt "error"}.
  
\item[{\tt mathweb\_apply}:]\ \\
  \hspace*{-1cm} {\small \tt string $\rightarrow$ string $\rightarrow$
    (list (list string)) $\rightarrow$ int $\rightarrow$ (list (list
    string)) $\rightarrow$ o.}\ \\ applies a method to a service
  object identified by the first argument. The second argument is the
  name of the service method. The third argument is a list of lists of
  strings representing the parameters for the method call. The fourth
  argument is an integer giving the timeout for the method call in
  seconds. The result of the method call is again encoded in a list of
  lists of strings and is unified with the fifth argument.
  
  The following example is taken from the module {\tt
    src/theories/maple.mod} and illustrates how to call the {\tt
    simplifyTerm} method of a {\maple} service:
  \begin{alltt}
mathweb_get_service "MAPLE" MapleService, 
print_open_math Formula OMFormula, 
OMObj is "'OMOBJ'(" ^ OMFormula ^ ")", 
mathweb_apply MapleService "simplifyTerm" [["1", OMObj]] 100 Result.
 \end{alltt} \vspace*{-0.4cm}
 First, a {\maple} service object is requested. Then a given {\tt
   Formula} is translated into {\openmath} representation. The
 {\openmath} object is given as the first (and only) argument to the
 {\tt simplifyTerm} service of {\maple}.
\item[{\tt mathweb\_leave\_service}:] \ \\
  {\small\tt  string -> o.}\\
  leaves the service object identified by the first argument. The
  service object and the corresponding reasoning system (e.g. a
  {\maple} process) is terminated. {\mathwebsb} clients should always
  leave service objects when they are no longer needed.
\end{description}


\noindent  We implemented the module
\url{src/io/print_open_math.mod} to translate {\lclam}'s formulae into
the {\openmath} standard using the core {\openmath} Content
Dictionaries (CDs). Thus, the module forms one half of an {\openmath}
phrase-book for {\lclam}. The translation table for {\lclam}'s symbols
is distributed over the theory files \url{src/theories/arithmetic},
\url{src/theories/analytica}, and
\url{src/theories/constructive_logic} to keep the {\openmath}
representation close to the definition of the symbols.


Using the {\tt mathweb} module, {\lclam} can now access every
reasoning system available in the {\mathwebsb}.  Possible applications
are:
\begin{description}
\item[Using ATPs to prove simple subgoals:] This approach has already
  been used in the {\OMEGA} proof planner to restrict the search
  space. In some cases, even higher order problems can be transformed
  to first order problems and then sent to one or more first order
  ATPs in the {\mathwebsb}.
%In {\OMEGA}, first order
%  resolution proofs are translated into natural deduction proofs by
%  the {\tramp} system.  This translation is not possible in {\lclam}
%  because in the current version {\lclam} does not have an associated
%  theorem prover with a logical calculus and tactics.
\item[Using ATPs on the control level:] It is a known shortcoming of
  {\lclam} that it does not check the consistency of hypotheses after
  performing a case split. This leads to {\lclam} missing easy proofs
  by inconsistency. Modern ATPs are very efficient and could detect
  trivial inconsistencies in a few milliseconds. We therefore try to
  prune inconsistent search paths in proof planning with the help of 
  ATPs like {\otter}.
\item[CAS computation in proof planning:] Due to our positive
  experience with CAS computations in many proof planning domains, we
  think that the use of CASs in inductive proof planning can enable
  {\lclam} to solve problems it couldn't solve before. The rewriting
  capabilities of a CAS can complement the rewriting of {\lclam} and
  can thus enhance the reasoning capabilities of {\lclam}.
\end{description}

Until now, we focused on the latter and formalised problems taken from
the {\analytica} system~\cite{Clarke92-1,BaClZh:aectpsc98} and the
{\clamlite} system~\cite{Walsh00}\footnote{NOTE: Due to a bug in
  {\teyjus}'s memory management, most of the examples do not run with
  {\teyjus} Version 1.0-b30p2.}. The {\analytica} problems can be
found in the theory file \url{src/theories/analytica.mod} and the
summation problems in the file \url{src/theories/sums.mod}.  During
the planning for these problems, {\lclam} uses {\maple}'s {\tt
  simplifyTerm} service which gets a term (formula) in {\openmath}
representation as an input argument. It returns the {\openmath}
representation of the term (formula) resulting from the call of
{\maple}'s {\tt simplify} function.  For the access of {\maple}, we
defined the {\tt maple\_simplify\_meth} which calls the {\tt
  simplifyTerm} service of {\maple} on the current subgoal and
introduces the resulting formula as a new subgoal. The method is
defined in the module \url{src/theories/maple.mod}. It should fail if
{\lclam} is in standalone mode and no {\mathwebsb} connection can be
established.  We added {\tt maple\_simplify\_meth} to the compound
methods {\tt induction\_top} and {\tt fertilise} defined in the module
{\tt src/theories/induction.mod}.


\section{Services offered by {\lclam}}
All services offered by {\lclam} are based on the
{\openmath}~\cite{CapCoh:doms98} and the
{\omdoc}~\cite{Kohlhase:otormd00} standard. We implemented a
translation service (the second half of a phrase-book) to translate
incoming formulae, definitions, and conjectures into {\lclam}'s higher
order abstract syntax. For the sake of efficiency, this translation is
performed by the {\mathwebsb} wrapper.  {\lclam} currently offers two
services to the {\mathwebsb}:
\begin{description}

%       meth planProblem(Conjecture  ?Result
%                        method: Method   <= "(induction_top with_critics)"
%                        timeout: TimeOut <= 60 )
  
\item[{\tt planProblem:}] This service takes an {\omdoc} document,
  containing a single conjecture, as an argument. The service starts
  the {\lclam} proof planning mechanism on the conjecture. In our
  current implementation, the service expects the conjecture to be
  about natural number arithmetic. We plan an extension of the service
  such that clients can also provide the theory the conjecture is
  defined in.
  
  Client applications using the {\tt planProblem} service can use
  optional arguments to determine which proof strategy (compound
  method) {\lclam} should use for the planning attempt, and to give a
  time limit in seconds.  In the current implementation, the service
  simply returns the {\openmath} symbol $true$ if {\lclam} could find
  a proof plan within the given time limit, and $false$ if no proof
  plan could be found.
%In section \ref{sec:concl}, we describe
%  possible future extensions of the {\tt planProblem} service.
  
\item[{\tt ripple:}] Rippling is one of the most successful heuristics
  for guiding (inductive) proof planning. Therefore, {\lclam} offers
  its rippling mechanism as a separate service to the {\mathwebsb}.
  The service is given a single {\omdoc} document as an input. The
  {\omdoc} must contain a non-empty set of rewrite rules, formalised
  as lemmas, and a goal sequent $H\vdash \phi$ as a conjecture. The
  {\tt ripple} service tries to reduce the difference between $\phi$
  and the best suitable hypothesis in $H$ using the rewrite rules.
%\ednote{ld: Is
%    this right? Or does it reduce w.r.t.. all hyps?}.
% The rewrite rules
%  must be specified separately using the {\tt setRewriteRules}
%  service.\ednote{jz: We could actually put the two services together
%    in one. This would of course mean that we lose the context after
%    every call.}
  The {\tt ripple} service also tries to apply fertilisation to reduce
  the goal $\phi$ to the trivial goal $true$.  The service returns the
  {\openmath} symbol $true$ if this was successful and $false$
  otherwise.  In a future version, the {\tt ripple} service should us
  the partial planner, implemented by Louise Dennis, to ripple as far
  as possible and return an {\omdoc} which contains the resulting
  proof planning goal as a sequent $H\vdash \phi'$.
    
%\item[{\tt setRewriteRules:}] is used to tell {\lclam} which set of rewrite
%\item[{\tt setRewriteRules:}] is used to tell {\lclam} which set of rewrite
%  rules it should use for the next {\tt ripple}. The rewrite rules should be
%  provided as definitions or lemmas in {\omdoc} format, i.e. as a single
%  {\omdoc} document containing a list of assertion elements.\ednote{jz: maybe we
%    should show an example in a figure. Anyway we should at least show one
%    {\openmath} formula somewhere. Makes a good impression.}. Using the {\tt
%    setRewriteRules} service, a client application can set up an simple {\it
%    context} such that it does not have to send the rewrites again and again
%  for every call of {\tt ripple}. \footnote{There is still a lot of conceptual
%    work to be done on the notion of {\it context} in communication between
%    reasoning systems and this is just a first step.}

\end{description}
%The {\mathwebwrapper also forwards {\mathwebsb} service calls performed by
%{\lclam}.
The services offered by {\lclam} can be used by other reasoning
systems via the {\mathwebsb}. We made first experiments with the use
of the {\tt planProblem} service and the {\tt ripple} service within
the {\OMEGA} proof planner.  We formalised problems in the natural
number theory of {\OMEGA} and implemented proof planning methods that
call the {\tt planProblem} and the {\tt ripple} service of {\lclam} to
close open subgoals or to reduce a subgoal to a simpler one,
respectively.

To see {\OMEGA} calling {\lclam}'s services, do the following:\\
Start an omega by typing in a shell:
\begin{itemize}
\item \url{loui-local}
\end{itemize}
A window with the GUI of {\OMEGA} should appear. Read in a problem and plan it:
\begin{itemize}
\item choose the menu  {\tt File}$\rightarrow${\tt Read}$\rightarrow${\tt Problem}
\item Click {\tt Choose File...}
\item choose {\tt /hame/jzimmer/xmp/plus2right.post}
\item execute one planning step with the menu {\tt
    Planner}$\rightarrow${\tt Step Plan} or with {\tt CTRL+t}.
\end{itemize}
During the planning step, the {\OMEGA} proof planner tries to apply
methods for the call of both the {\tt ripple} and the {\tt
  planProblem} service. This is why you see two windows of {\lclam}
services popping up on the screen. In our example only the {\tt
  planProblem} leads to success and the proof planning goal in
{\OMEGA} is closed with the justification {\tt LCLAM-M}, i.e. the
proof planning method that called {\lclam}'s {\tt planProblem}
service. You can also see a window with title "Oz Browser" which shows
the lemmas {\OMEGA} sends to {\lclam} for the rippling\footnote{Change
  the representation mode in the Browser menu "Options" to see show
  strings and virtual strings strings properly. Then select the whole
  Browser output and type {\tt C-b}. Further information can be found
  at \url{http://www.mozart-oz.org/documentation/browser}.}.

%One advantage of passing lemmas from {\OMEGA}'s theories as rewrites
%to {\lclam}'s {\tt ripple} service is that the rewriting process is
%completely independent of {\lclam}'s theories. Thus, {\lclam} can be
%used as an abstract rewriting engine whose termination is guaranteed.
%However, the current version of {\lclam} does not maintain a trace of
%the positions of subterms a rewrite rules was applied to. The latter
%would allow the {\tt ripple} service to tell a client application, like
%{\OMEGA}, exactly which rewrite has been applied to which subterm of
%the planning goal not just the rewrite rule that had been applied to
%that goal. {\OMEGA} could then use this information to construct a
%natural deduction proof for the reasoning steps performed during
%rippling.


%%============================================
%% Future Work
%%============================================
\section{Possible Future Work} 
\label{sec:future}
% \begin{itemize}
% \item more context and interaction in service calls
% \item decision procedures in {\mathwebsb}
% \item use of {\mbase} as mediator
% \end{itemize}
%The preliminary results we got from our experiments with the use of
%CAS in inductive proof planning were promising and in the future one
%could extend our experiments to a fully-fledged case study by
%formalising all theorems about closed forms of summations listed
%in~\cite{TobyMaple}. We plan a more detailed comparison of our work
%with~\cite{TobyMaple} on the basis of qualitative results (the number
%of proof plans found) and on quantitative results (runtime
%comparisons).
Possible directions for future work include the use of other external
reasoning systems such as ATPs or decision procedures in {\lclam} as
described in section \ref{sec:mw-using-services}.

Our experiments with the use of Computer Algebra computations in proof
planning could be extended to a full case study. Especially the
summation problems of \cite{Walsh00} are interesting for this application.

The services offered by {\lclam} could be refined and extended. The
{\tt ripple} service, for instance, should return the subgoal after
one application of the rippling method (and fertilisation). The
service could also return the list of rewrite rules applied, and the
positions of the subterms the rules were applied on.  The {\tt
  planProblem} service could be extended to take the definition of the
theory a problem is formulated in, and to return a (partial) proof
plan in {\omdoc} encoding.

Furthermore, {\lclam} offers the means to formalise and prove theorems
in non-standard analysis (NSA)~\cite{Maclean02}. Using NSA, {\lclam}
could already find proof plans for the limit theorems {\limplus} and
{\limtimes} and some other analysis theorems, e.g., the mean-value
theorem. In contrast to the classical $\eps$-$\delta$ proofs, NSA
proofs tend to be much shorter and more intuitive.  Hence, it would be
interesting to use {\lclam}'s NSA theory to construct alternative
proofs for some of the complex theorems proved by the {\analytica}
system using the computational power of CASs available in the
{\mathwebsb}.

% Significant work has been done by \name{P. Jani\v{c}i\'c} on the
% integration of different decision procedures to produce more powerful
% ones~\cite{Janicic01} using a proof planning framework.  Decision
% procedures are of general interest for any reasoning system,
% especially for DSs, because they provide efficient algorithms to solve
% subproblems in a decidable theory.  We therefore intend to integrate
% decision procedures in the {\mathwebsb} and define a reasoning service
% common to all decision procedures. {\lclam} could then use the
% {\mathwebsb} for a homogeneous, distributed access of various decision
% procedures.

% \ednote{ld: not sure how all this fits together, it doesn't
%   make much sense to me.  The framework for constructing decision
%   procedures is implemented in \lclam\ although I think Predrag wanted
%   to call external reasoners on occasion but he was using methodicals
%   to string them together}
 
The proper use of context in the communication between reasoning
systems is still an open research question. Context can not only
reduce the amount of information that has to be transfered between
systems, it is also crucial to establish more complex forms of
collaboration and coordination between reasoning systems. The {\lclam}
proof planner, for instance, offers the powerful {\it critics}
mechanism which analyses the failure of a proof attempt and gives
feedback to the user about possible ways of correcting the proof.
This feedback can include generalising the original goal, modifying
the chosen induction scheme, or speculating a new rewrite rule.
Potentially this feedback could also be given to another reasoning
system using {\lclam} and this would involve far more complex
interactions in terms of context.  For instance, if {\lclam} were to
suggest modifying the induction scheme this new proposed scheme might
have to be transmitted back to the client system for verification in
terms of its own logic. To enable this form of fine-grained
interaction between reasoning systems we need to develop a general
notion of context in inter-system communication.  {\lclam} could then
be used as a prototypical reasoning systems that builds up a context
when communicating with other systems.
 





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
